    1. 무결성에 대해 설명해주세요
    → 무결성 제약조건의 종류, 무결성을 유지해야 하는 이유는?
    2. 정규화에 대해 설명해주세요
    3. 정규화의 장단점은 무엇인가요?
    4. 정규화의 유형에 대해 설명해주세요
    5. 역정규화를 하는 이유는 무엇인가요?
    6. 트랜잭션이란 무엇인가요?
    → 트랜잭션이 필요한 이유는?
    7. 트랜잭션의 성질에 대해 설명해주세요.(4가지)
    8. COMMIT과 ROLLBACK에 대해 설명해보세요.
    9. 인덱스에 대해 설명해주세요.
    10. 인덱스의 자료구조에는 어떤 것들이 있나요?
    11. 인덱스의 장단점은?

<hr>

## 데이터의 무결성

> 데이터의 무결성

- 무결성이란?
  - 데이터의 정확성, 일관성, 유효성이 유지되는 것을 의미한다.

> 무결성 제약조건

- 개체 무결성, 참조 무결성, 도메인 무결성, 고유 무결성, NULL 무결성, 키 무결성이 있다.
- ✓ 개체 무결성: 각 릴레이션의 기본키를 구성하는 속성은 널값이나 중복된 값을 가질 수 없다.
- ✓ 참조 무결성: 외래키 값은 NULL이거나 참조하는 릴레이션의 기본키 값과 동일해야 한다.
- 도메인 무결성: 속성들의 값은 정의된 도메인에 속한 값이어야 한다.
- 고유 무결성: 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우, 릴레이션의 각 튜플이 가지는 속성 값들은 서로 달라야 한다.
- NULL 무결성: 릴레이션의 특정 속성 값은 NULL 될 수 없다.
- 키 무결성: 각 릴레이션은 최소한 한 개 이상의 키가 존재해야 합니다.

> 무결성을 유지해야 하는 이유는?

- 무결성이 유지되어야 DB에 저장된 값에 대한 신뢰성이 확보된다.

## 정규화

> 이상현상

1. 삭제 이상 (Delete Anomaly)
   튜플 삭제시 필요한 데이터까지 연쇄 삭제가 발생하여 데이터가 손실되는 현상이다.

2. 삽입 이상 (Insert Anomaly)
   튜플 삽입시 지정하지 않은 속성값이 NULL을 갖거나, 원하지 않는 자료가 삽입되는 현상이다.

3. 갱신 이상 Update Anomaly
   데이터 갱신시 일관성 유지가 안되는 현상이다.

> 함수의 종속성

- 함수적 종속: X의 값에 따라 Y값이 결정될 때 X -> Y로 표현하는데, 이를 Y는 X에 대해 함수적 종속 이라고 한다.
  <br> 예를 들어 학번을 알면 이름을 알 수 있는데, 이 경우엔 학번이 X가 되고 이름이 Y가 됩니다.
  X를 결정자, Y는 종속자라고 한다.
- 함수적 종속에서 X의 값이 여러 요소일 경우, 즉, {X1, X2} -> Y일 경우
  <br> X1와 X2가 Y의 값을 결정할 때, 이를 완전 함수적 종속 이라고 한다.
  <br> X1, X2 중 하나만 Y의 값을 결정할 때, 이를 부분 함수적 종속 이라고 합니다.

> 정규화(Normalization)

- 정규화란?
  - 데이터의 중복을 최소화하기 위해 데이터를 구조화하는 작업
  - 이상현상이 존재하는 릴레이션을 분해하여 여러 개의 릴레이션을 생성하는 과정을 의미한다.
    <br> 릴레이션은 분해되는 정도에 따라 정규형 단계로 나누어지며 정규형이 높아질수록 이상현상은 줄어든다.
    
> 정규화의 유형
  - 제 1 정규형 : 릴레이션에 속한 모든 속성의 도메인이 원자값(Atomic Value, 하나의 값)으로 구성되어 있어야 한다.
  - 제 2 정규형 : 제1정규형에 속해있고, 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속되어야 한다.
  - 제 3 정규형 : 제2정규형에 속해있고, 기본키가 아닌 모든 속성이 기본 키에 이행적 함수 종속이 되지 않아야 한다.
    (이행적 종속: A -> B, B -> C가 성립할 때 A -> C가 성립되는 것을 의미)
  - BCNF 정규형 : 제3 정규화를 진행한 테이블에 대해 모든 결정자가 후보키가 되도록 테이블을 분해하는 것이다.
    > 정규화의 장단점
- 장점
  - DB 변경 시 이상 현상(Anomaly) 제거
  - 저장 공간의 최소화 (용량감소)
  - 데이터 구조의 안정성 및 무결성 유지
  - 데이터 삽입, 삭제, 수정 시 테이블 재구성의 필요성 감소
- 단점
  - 릴레이션의 분해로 인해 릴레이션간의 JOIN 이 많아져서 질의에 대한 응답 시간이 느려질 수 있다.
> 역정규화
  - 정규화를 통해 분리되었던 릴레이션에서 중복을 허용하고, 다시 통합하거나 분할하여 구조를 재조정하는 과정이다.
- 역정규화를 하는 이유
  - 조인으로 인하여 성능이 저하되는 문제를 해결하기 위해 사용한다.
  - 정규화에 충실하여 종속성, 활용성은 향상 되었지만 수행속도가 느려진 경우
  - 다량의 범위를 자주 처리해야하는 경우
  - 특정 범위의 데이터만 자주 처리하는 경우
  - 요약/집계 정보가 자주 요구되는 경우

## 트랜잭션

> 트랜잭션

- 트랜잭션이란?
  - 데이터베이스의 상태를 변화시키기 위해 수행되는 작업단위
  - 상태 변화 : SQL 질의어를 통해 DB에 접근하는 것(SELECT, INSERT, DELETE, UPDATE)
- 트랜잭션이 필요한 이유?
  - Insert, delete, update등의 데이터 변경문의 실행을 트랜잭션을 통해 관리 할 수 있으며 이를 통해 데이터베이스의 무결성과 일관성을 보장할 수 있기 때문.

> 트랜잭션 특징

  - 원자성(Atomicity)
    <br>트랜잭션을 구성하는 연산이 DB에 모두 반영되거나, 혹은 전혀 반영되지 않아야 된다.
  - 일관성(Consistency)
    <br>트랜잭션의 작업 처리 결과는 항상 일관성 있어야 한다.
  - 독립성(Isolation)
    <br> 둘 이상의 트랜잭션이 동시에 실행되고 있을 때, 어떤 트랜잭션도 다른 트랜잭션 연산에 끼어들 수 없다.
    <br> 각 트랜잭션은 독립적으로 수행되어야 한다.
  - 지속성(Durability)
    <br> 트랜잭션이 성공적으로 완료된 후, 수행된 결과는 영구적으로 반영되어야 한다.

> 트랜잭션의 상태

- 활동 상태 : 트랜잭션이 수행하기 시작
- 부분 완료 상태 : 트랜잭션이 마지막 연산을 처리
- 완료 상태 : 트랜잭션이 commit 연산을 처리
- 실패 상태 : 다양한 원인으로 인해 정상적인 트랜잭션 수행이 불가능
- 철회 상태 : 실패 상태의 트랜잭션이 rollback연산을 했을 경우
- 완료상태, 철회상태의 트랜잭션 -> 트랜잭션의 종료로 간주

<br> 종료된 트랜잭션은 상황에 따라 다시 수행되거나, 폐기됨.

> 트랜잭션의 주요 연산: 커밋(commit), 롤백(rollback)

- Commit
  <br> 하나의 트랜잭션이 성공적으로 끝났고, DB가 일관성있는 상태일 때 이를 알려주기 위해 사용하는 연산
- Rollback
  <br> 하나의 트랜잭션 처리가 실패했음을 알려주는 연산.
  <br> 지금까지 실행한 연산의 결과가 취소되고 트랜잭션이 수행되기 전의 상태로 돌아감.

> 트랜잭션의 병행제어(Concurrency Control)

- 트랜잭션이 병행 수행될 때 트랜잭션이 데이터베이스의 일관성을 파괴하지 않고, 다른 트랜잭션에 영향을 주지 않도록 트랜잭션 간의 상호작용을 제어하는 것

- 트랜잭션이 병행 수행될 때 나타날 수 있는 문제점

  - 갱신 분실
    <br>하나의 트랜잭션이 수행한 데이터 변경 연산의 결과를 다른 트랜잭션이 덮어서 변경 연산이 무효되는 것
  - 모순성
    <br>하나의 트랜잭션이 여러 개의 데이터 변경 연산을 실행할 때, 일관성 없는 상태의 데이터베이스에서 데이터를 가져와 연산 실행 시 모순된 결과가 발생하는 것
  - 연쇄 복귀
    <br>병행 수행되던 둘 이상의 트랜잭션 중 어느 한 트랜잭션에 오류가 발생하여 Rollback 하는 경우 다른 트랜잭션들도 함께 Rollback 되는 현상을 말한다.
  - 비완료 의존성 (uncommitted Dependency)
    <br>하나의 트랜잭션 수행이 실패한 후 회복하기 전에 다른 트랜잭션이 실패한 갱신 결과를 참조하는 현상을 말한다.

- 병행 제어 기법
    - 로킹(Locking)
      - 로킹: 트랜잭션이 접근하려는 데이터를 다른 트랜잭션이 접근하지 못하도록 잠그는(lock) 병행 제어 기법
      - 로킹 단위: 한 번에 로킹할 수 있는 데이터 크기. 필드(Field), 레코드(Record), 테이블(Table), 파일(File), 데이터베이스(Database) 모두 가능
      - 로킹 단위 ↑ : 병행 제어가 단순, 관리 편함. 병행성 수준 ↓ <br>
        로킹 단위 ↓ : 병행 제어가 복잡, 오버헤드 ↑, 병행성 수준 ↑, 데이터베이스 공유도↑
      - 로킹은 lock(트랜잭션이 사용할 데이터에 대한 독점권을 가지기 위해 사용)과 unlock(트랜잭션이 데이터에 대한 독점권을 반납하기 위해 사용) 연산을 사용.
      - 로킹 규약<br>
        (1) 트랜잭션 T가 공유 데이터 x를 접근하려면 먼저 lock(x)을 해야 한다.<br>
        (2) 공유 데이터를 사용한 T는 반드시 unlock(x)을 해야 한다.<br>
        (3) 다른 트랜잭션에 의해 lock(x)가 실행되었다면, 트랜잭션 T는 lock(x)을 실행하지 못한다.<br>
        (4) 트랜잭션 T가 lock(x) 한 것을 다른 트랜잭션이 unlock(x)할 수 없다.<br>
      - 문제점 : 하나의 트랜잭션만이 공유 데이터를 사용할 수 있는데, 실제로 읽기(read)만 하는 경우에는 동시에 접근해도 문제가 없기 때문에 이런 경우는 효율적이지 못하다. 이를 해결하기 위해 사용되는 것이 2단계 로킹 규약이다.

    - 2단계 locking 규약

      - 직렬 가능성을 보장할 수 있는 규약으로 각 트랜잭션의 lock과 unlock 요청을 확장 단계(Growing phase)와 축소 단계(shrinking phase)의 2단계로 실시하는 방식.
      - 확장 단계: 새로운 lock 연산 ⭕️, unlock 연산 ❌
      - 축소 단계: lock 연산 ❌, unlock 연산 ⭕️
      - 교착 상태 예방은 불가능하다.

- 교착 상태
  여러 트랜잭션이 특정 데이터에 lock을 한 채 다른 트랜잭션이 lock을 수행한 데이터에 접근하려고 할 때 실행을 하지 못하고 서로 무한정 기다리는 상태를 말한다.

## 인덱스

> 인덱스란?

- 데이터베이스 테이블에 대한 검색 속도를 높여주는 자료 구조이다.
- 테이블의 특정 컬럼(Column)에 인덱스를 생성하면, 해당 컬럼의 데이터를 정렬한 후 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장된다. 컬럼의 값과 물리적 주소를 (key, value)의 한 쌍으로 저장한다.

> 인덱스의 장단점

- 장점

  - 테이블을 검색하는 속도와 성능이 향상되며, 시스템의 전반적인 부하를 줄일 수 있다.
  - 인덱스에 의해 데이터들이 정렬된 형태를 갖게 된다.
    - 기존엔 WHERE문으로 특정 조건의 데이터를 찾기 위해서 테이블의 전체를 조건과 비교해야 하는 '풀 테이블 스캔(Full Table Scan)' 작업이 필요했는데, 인덱스를 이용하면 데이터들이 정렬되어 있기 때문에 조건에 맞는 데이터를 빠르게 찾을 수 있다. ORDER BY 문, MIN/MAX 같은 경우도 빠르게 수행할 수 있다.

- 단점
  - 인덱스를 관리하기 위한 추가 작업이 필요
  - 추가 저장 공간 필요
    - 별도의 메모리 공간에 저장되기 때문에 추가 저장 공간이 많이 필요하게 된다.
  - 잘못 사용하는 경우 오히려 검색 성능 저하
    - 전체 데이터의 10~15% 이상의 데이터 처리, 값의 range가 적은 컬럼인 경우 인덱스를 읽고 나서 다시 많은 양의 데이터를 조회해야 하기 때문.

> 인덱스를 항상 정렬된 상태로 유지해야 하기 때문에 인덱스가 적용된 컬럼에 삽입(INSERT), 삭제(DELETE), 수정(UPDATE) 작업을 수행하면 다음과 같은 추가 작업이 필요하다. <br> INSERT : 새로운 데이터에 대한 인덱스를 추가 <br> DELETE : 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업 수행 <br> UPDATE : 기존의 인덱스를 사용하지 않음 처리, 갱신된 데이터에 대한 인덱스 추가

> 인덱스를 사용하면 좋은 경우

- 데이터의 range가 넓고 중복이 적을수록, 조회가 많거나 정렬된 상태가 유용한 컬럼
- 규모가 큰 테이블 / 삽입(INSERT), 수정(UPDATE), 삭제(DELETE) 작업이 자주 발생하지 않는 컬럼 / WHERE나 ORDER BY, JOIN 등이 자주 사용되는 컬럼 / 데이터의 중복도가 낮은 컬럼

> 인덱스의 자료구조

- 해시 테이블(Hash Table)
  <br> key와 value를 한 쌍으로 데이터를 저장하는 자료구조로 key값을 이용해 대응되는 value값을 구하는 방식이다.
  <br> key에 컬럼의 값, value에 데이터의 위치로 인덱스를 구현한다.
  <br> 시간복잡도: O(1)
  <br> 해시 테이블은 등호 연산에 최적화되어 있다. 데이터의 정렬이 되어 있지 않기 때문에, 부등호 연산이 사용되는 경우 빠른 시간 내에 찾을 수 없다.

- B+Tree
  <br> B-Tree를 확장한 자료구조이다.
  <br> 리프 노드를 제외하고 Value를 담아두지 않기 때문에 노드의 메모리에 더 많은 Key를 저장할 수 있다.
  <br> 하나의 노드에 더 많은 Key들을 담을 수 있기에 트리의 높이는 더 낮아집니다.
  <br> Full Scan 수행 시, 리프 노드에 데이터가 모두 있기 때문에 리프 노드를 저장한 리스트에 대해 한 번의 선형 탐색만 수행하면 된다. -> B-tree에 비해 빠름.
