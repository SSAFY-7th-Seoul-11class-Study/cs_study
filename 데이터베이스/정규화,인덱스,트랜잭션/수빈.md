```
정규화, 인덱스, 트랜잭션 예상질문

1. 이상현상을 설명하고 이를 해결할 수 있는 방법을 설명하세요.
  ➡️ 이상현상의 종류
2. 정규화를 설명하고 정규화의 장단점을 설명하세요.
3. 정규화의 단점을 해결할 수 있는 방법을 설명하세요.
4. 인덱스를 설명하고 인덱스의 장단점을 설명하세요.
  ➡️ 인덱스를 사용하면 좋은 경우를 설명
5. 인덱스에 가장 많이 사용되는 자료구조를 말하고 그 이유를 설명하세요.
6. B-tree와 B+tree의 차이점을 설명하세요.
7. 트랜잭션과 트랜잭션의 특징을 설명하세요.
8. 가장 많이 사용되는 격리 수준을 말하고 설명하세요.
9. 격리 수준에 따라 발생하는 현상 3가지를 설명하세요.
10. '반복 가능하지 않은 조회' 현상과 '더티 리드' 현상의 차이점을 설명하세요.
11. 무결성에 대해 설명하세요.
12. 커밋과 롤백에 대해 설명하세요.
```

# 정규화(Normalization)

> 데이터의 중복을 최소화하게 데이터를 구조화하는 과정을 말한다.

<br>

## 목표

테이블 간에 중복된 데이터를 허용하지 않는 것

- 무결성을 유지할 수 있고, DB 저장 용량 또한 효율적으로 관리가 가능

<br>

## 제1 정규화

릴레이션의 모든 도메인이 더 이상 분해될 수 없는 원자값(Atomic Value)을 갖도록 릴레이션을 분해하는 것

<br>

## 제2 정규화

릴레이션이 제1 정규형이며 부분 함수의 종속성을 제거한 형태로 완전 함수 종속을 만족하도록 릴레이션을 분해하는 것이다.

`부분 함수의 종속성 : 어떠한 컬럼이 기본키의 부분집합에 의해 결정되는 것을 말한다.`

<br>

## 제3 정규화

릴레이션이 제2 정규형이며 기본키가 아닌 모든 속성이 이행적 함수 종속을 만족하지 않도록 릴레이션을 분해하는 것

`이행적 함수 종속성 : A컬럼 ➡️ B컬럼, B컬럼 ➡️ C컬럼이 성립할 때 A컬럼 ➡️ C컬럼이 성립되는 것을 말한다.`

<br>

## BCNF(보이스/코드) 정규화

릴레이션이 제3 정규형이며 모든 결정자가 후보키가 되도록 테이블을 분해하는 것이다.

`결정자 : X ➡️ Y 일 때, X는 결정자 Y는 종속자이다.`

<br>

## 정규화의 장단점

> 장점

- 각종 이상 현상들을 해결할 수 있다.
- 무결성을 유지하고, 데이터의 일관성을 높여준다.

> 단점

- 데이터 조회 시 많은 조인을 유발하기 때문에 CPU와 메모리를 많이 사용하여 응답시간이 느려질 수 있다.

<br>

## 역정규화(De-normalization)

시스템 성능 향상을 위해 정규화된 데이터 모델을 통합하는 작업으로, 의도적오르 정규화 원칙을 위배하는 행위이다.

<br>

### 반정규화의 대상이 되는 경우

1. 수행 속도가 느린 경우
2. 조인 연산을 너무 많이 사용하는 경우
3. 다량의 범위 혹은 특정 범위를 자주 처리하는 경우

<br>

> 종류

- 테이블 통합/분할/추가
- 중복 속성 추가

<br>

## 이상현상(Anomaly)

테이블 내의 데이터들이 불필요하게 중복되어 테이블을 조작할 때 발생되는 데이터 불일치 현상이다.

<br>

1. 삽입 이상(insertion anomaly) : 원하지 않는 자료가 삽입되거나 key가 없어 삽입하지 못하는 문제
2. 삭제 이상(deletion anomaly) : 하나의 자료만 삭제하고 싶지만, 그 자료가 포함된 튜플 전체가 삭제됨으로 원하지 않는 데이터 손실이 발생하는 문제
3. 갱신 이상(update anomaly) : 일부만 변경하여 데이터가 불일치하는 모순

<br>

---

<br>

# 인덱스(Index)

> 데이터베이스 테이블에 대한 검색 성능의 속도를 높여주는 자료구조. 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 한다.

<br>

## 인덱스의 장단점

> 장점

- 테이블을 조회하는 속도와 성능을 향상시킬 수 있다.
- 시스템 부하를 줄일 수 있다.

> 단점

- 인덱스를 관리하기 위한 추가작업이 필요하다.
- 인덱스를 잘못 사용할 경우 오히려 검색 성능이 저하될 수 있다.
- 인덱스를 관리하기 위해 추가적인 저장공간이 필요하다.

<br>

## 인덱스를 사용하면 좋은 경우

- 삽입, 갱신, 삭제가 자주 발생하지 않는 컬럼
- JOIN, WHERE, ORDER BY에 자주 사용되는 컬럼
- 데이터의 중복도가 낮은 컬럼

<br>

## 인덱스 자료구조

> 해시 테이블

해시 테이블 기반의 인덱스는 key를 데이터, value를 데이터의 위치로 사용하여 인덱스를 구현한다. 시간복잡도는 O(1)

해시 테이블 기반의 인덱스는 등호 연산에만 최적화되어있기 때문에 부등호 연산이 자주 사용되는 경우는 추가적인 순차 검색이 필요하여 빠른시간 내에 찾을 수 없다.

> B+ tree

하나의 노드에 여러 데이터가 존재할 수 있고, 리프노드끼리 연결리스트로 연결되어 있다.
또한 리프노드에만 데이터가 존재한다.

등호 연산뿐만 아니라, 부등호 연산을 이용할 경우 리프노드의 연결리스트를 통해 순차 검색을 효율적으로 할 수 있다는 장점이 있다.

<br>

---

<br>

# 트랜잭션(Transaction)

> 데이터베이스의 상태를 변화시키기 위해 수행되는 작업의 단위

```
상태를 변화시키는 것
- SELECT
- INSERT
- DELETE
- UPDATE
```

<br>

## 트랜잭션의 특징(ACID)

1. 원자성(atomicity) : 트랜잭션이 모두 수행되었거나 되지 않았거나를 보장하는 특징
2. 일관성(consistency) : 트랜잭션의 작업 결과가 항상 일관되어야 한다는 뜻
3. 독립성(isolation) : 하나의 트랜잭션이 다른 트랜잭션에 끼어들 수 없다는 것
4. 지속성(durability) : 트랜잭션이 성공적으로 완료되면 영구적으로 결과에 반영되어야 한다는 뜻

<br>

## 트랜잭션 격리수준(Isolation Level)

트랜잭션을 여러 개의 격리 수준으로 나누는 것

> 종류

1. READ UNCOMMITED : 가장 낮은 격리 수준으로, 하나의 트랜잭션이 커밋되기 이전에 다른 트랜잭션에 노출되는 문제가 있다.
2. READ COMMITED : 가장 많이 사용되는 격리 수준으로, 다른 트랜잭션이 커밋하지 않은 정보는 읽을 수 없고 커밋 완료된 데이터에 대해서만 조회를 허용한다.
3. REPEATABLE READ : 하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없도록 막아주지만 새로운 행을 추가하는 것은 막지 않는 것
4. SERIALIZABLE : 트랜잭션을 순차적으로 진행시키는 것으로, 여러 트랜잭션이 동시에 같은 행에 접근할 수 없다.

<br>

### 격리 수준에 따라 발생하는 현상

1. 팬텀 리드(phantom read) : 한 트랜잭션에서 일정 범위의 데이터를 두 번 이상 읽었을 때, 첫번째 쿼리에서 없던 데이터가 두번째 쿼리에서 나타나는 현상
2. 반복 가능하지 않은 조회(non-repeatable read) : 한 트랜잭션에서 같은 데이터를 두 번 이상 조회 시, 그 값이 다른 경우
3. 더티 리드(dirty read) : 한 트랜잭션이 실행 중일 때 다른 트랜잭션에 의해 수정되었지만 아직 '커밋되지 않은' 행의 데이터를 읽을 수 있을 경우
