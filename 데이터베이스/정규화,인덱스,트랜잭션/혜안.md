### 예상질문

```
1. 인덱스의 장단점에 대해 설명해주세요.
2. 인덱스를 사용하면 좋은 경우를 설명해주세요.
3. 인덱스를 구현하기 위한 대표적인 자료구조 2가지를 설명해주세요.
4. 인덱스를 생성할 때 hash보다 b-tree를 사용하는 이유를 설명해주세요.
5. 트랜잭션과 트랜잭션의 4가지 특성에 대해 설명해주세요.
6. Commit과 Rollback에 대해 설명해주세요.
7. 트랜잭션을 병행으로 처리하려고 할 때 발생할 수 있는 문제를 설명해주세요.
8. 트랜잭션을 병행으로 처리할 때 위와 같은 문제를 방지하기 위한 방법을 설명해주세요.
9. 정규화의 목적에 대해 설명해주세요.
10. 각 정규화 단계에 대해 설명해주세요.
11. 역정규화를 하는 이유에 대해 설명해주세요.
```

---

## 1. Index

### 1.1 Index란?

> 추가적인 쓰기 작업과 저장공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조

### 1.2 Index의 장단점

#### 장점

- 테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있다.
- 전반적인 시스템의 부하를 줄일 수 있다.

#### 단점

- 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요하다.
- 인덱스를 관리하기 위해 추가 작업이 필요하다.
- 인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생할 수 있다.

### 1.3 Index 사용 시 상황분석

#### Index를 사용하면 좋은 경우

- Where절에서 자주 사용되는 컬럼
- 외래키가 사용되는 컬럼
- Join에 자주 사용되는 컬럼

#### Index 사용을 피해야 하는 경우

- Data 중복도가 높은 컬럼
- DML이 자주 일어나는 컬럼

### 1.4 Index 자료구조

#### 1.4.1 Hash Table

- 컬럼의 값으로 생성된 해시를 기반으로 인덱스를 구현한다.
- 시간복잡도가 O(1)이라 검색이 매우 빠르다.
- 부등호(<, >)와 같은 연속적인 데이터를 위한 순차 검색이 불가능하다.

#### 1.4.2 B+ Tree

- 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조이다.
- BTree의 리프노드들을 LinkedList로 연결하여 순차 검색을 용이하게 하였다.
- 해시 테이블보다 나쁜 O(log2nlog2n) 의 시간복잡도를 갖지만 해시테이블보다 흔하게 사용된다.

#### 1.4.3 인덱스를 생성하는데 b-tree를 사용하는 이유

> 데이터에 접근하는 시간복잡도가 O(1)인 hash table 이 더 효율적일 것 같지만, SELECT 질의의 조건에는 부등호(<>) 연산도 포함이 된다. hash table 을 사용하게 된다면 등호(=) 연산이 아닌 부등호 연산의 경우에 문제가 발생한다. 동등 연산(=)에 특화된 hashtable은 데이터베이스의 자료구조로 적합하지 않다.

## 2. 트랜잭션

### 2.1 트랜잭션이란?

> 데이터베이스의 상태를 변화시키기 위해 수행하는 작업 단위

### 2.2 트랜잭션의 4가지 특징 (ACID)

#### Atomicity(원자성)

- 트랜잭션의 연산이 DB에 모두 반영되던지 전혀 반영이되지 않던지 둘중에 하나만 수행해야한다.

#### Consistency(일관성)

- 트랜잭션이 성공적으로 완료된 후에는 언제나 일관성 있는 DB상태로 변환되어야한다.

#### Isolation(독립성)

- 수행중인 트랜잭션이 완전히 완료되기 전에는 다른 트랙잭션에서 수행 결과를 참조할 수 없다.

#### Durability(영속성)

- 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.

### 2.3 Commit과 RollBack

#### 2.3.1 Commit

해당 트랜잭션으로 반영된 DB의 변경사항을 저장하는 것

#### 2.3.2 Rollback

해당 트랜잭션으로 반영된 DB의 변경사항을 취소하는 것

### 2.4 트랜잭션 병행 처리

#### 2.4.1 트랜잭션을 병행처리하려고 할 때 발생할 수 있는 문제

- 갱신 내용 손실: 동시에 하나의 데이터가 갱신될 때 하나의 갱신이 누락되는 경우
- 현황 파악 오류: 하나의 데이터 갱신이 끝나지 않은 시점에서 다른 트랜잭션이 해당 데이터를 조회하는 경우
- 모순성: 두 트랜잭션이 동시에 실행될 때 데이터베이스가 일관성이 없는 모순된 상태로 남는 문제
- 연쇄 복귀: 두 트랜잭션이 하나의 레코드를 갱신할 때 하나의 트랜잭션이 롤백하면 다른 하나의 트랜잭션 마저 롤백이 되는 문제

#### 2.4.2 위와 같은 문제를 방지하기 위한 방법

로킹 제어 기법(어떤 트랜잭션이 특정 DB의 데이터를 사용할 때 DB의 일정부분을 Lock시키고 트랜잭션이 완료될때 해당부분을 Unlock시키는 방법)을 사용한다.

## 3. 정규화

### 3.1 정규화란?

> 관계형 데이터베이스에서 중복을 최소화하기 위해 데이터를 구조화하는 작업이다. 좀 더 구체적으로는 불만족스러운 나쁜 릴레이션의 애트리뷰트들을 나누어서 좋은 작은 릴레이션으로 분해하는 작업을 말한다.

### 3.2 정규화의 목적

> 데이터의 중복을 최소화하고 테이블의 삽입, 삭제, 갱신 과정에서 발생하는 이상현상을 방지하기 위함

### 3.3 정규화의 단계

#### 제 1정규화

- 테이블에 있는 모든 속성의 도메인이 원자값만으로 되어있도록 바꿈. 모든 항목에 값이 있어야 하며, 중복 기능 열이 없어야 함

#### 제 2정규화

- 테이블의 모든 컬럼에서 부분 함수적 종속을 제거함

#### 제 3정규화

- 기본키를 제외한 속성들 간의 이행적 함수 종속을 제거함

#### 제 BCNF화

- 결정자이면서 후보키가 아닌 것들을 제거함

#### 제 4정규화

- 다치 종속 제거함

### 3.4 역정규화를 하는 이유

> 정규화를 진행할수록 하나의 테이블을 여러 테이블로 나누게 되는데, 만약 데이터 호출 시 여러 테이블을 불러서 Join을 해줘야한다면 이 비용도 만만치 않기 때문에 역정규화를 한다.
