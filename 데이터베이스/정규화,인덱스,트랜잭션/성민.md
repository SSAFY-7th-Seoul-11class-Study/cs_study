```
1. 인덱스에 대해 설명해주세요.
2. DBMS에서 인덱스는 어떻게 관리하는지
3. 인덱스 생성 시 왜 b-tree 알고리즘을 사용할까요?
4. 인덱스를 사용하기 좋은 경우는 언제일까요?
5. 그럼 어떤 column 에 인덱스 설정하는 게 좋을까요?
6. 이상현상의 종류에 대해 말해주세요.
7. 트렌젝션이 무엇일까요?
8. 트랜젝션의 특성에 대해 설명해주세요.
9. 교착 상태에 대해 아시나요?
10. 그럼 교착상태를 방지하기 위한 방법에 대해 설명해주세요.
11. 역정규화를 하는 이유는?
12. 정규화의 장단점을 말해주세요.
13. 정규화에 대해 설명해주세요
```

## 설명

- 인덱스란?

  - 말 그대로 책의 맨 처음 또는 맨 마지막에 있는 색인. 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만들어 검색 속도를 향상합니다.
  - 데이터베이스의 테이블에 대한 검색 속도를 향상시켜주는 자료구조.
  - 항상 정렬된 상태를 유지하기 때문에 탐색하는데는 빠르지만, 새로운 값을 추가,삭제, 수정하는 경우는 실행속도가 느려진다.

- Index 자료구조

  - B+ Tree 인덱스 알고리즘

    - 일반적으로 사용되는 알고리즘. 칼럼의 값을 변경하지 않고 원래의 값을 이용하여 인덱싱하는 알고리즘

  - Hash 인덱스 알고리즘

    - 칼럼의 값으로 해시 값을 계산하여 인덱싱하는 알고리즘. 값을 변형해서 인덱싱하기 때문에, 특정 문자로 시작하는 값으로
      검색을 하는 전방 일치와 같이 값의 일부만으로 검색하고자 할 때는 해시 인덱스를 사용할 수 없다. 주로 메모리 기반
      데이터베이스에서 사용

  - Hash table이 데이터에 접근하는 시간복잡도가 O(1)이라 더 효율적이라 생각하겠지만 SELECT 문은 부등호 연산도 포함이 된다.
    Hash table을 사용한다면 등호(=)가 아닌 부등호 연산의 경우 문제가 발생하기 때문에 주로 b-tree로 인덱스를 사용한다.

- 인덱스를 사용하면 좋은 경우

  - 규모가 큰 테이블
  - 삽입(INSERT), 수정(UPDATE),삭제(DELETE) 작업이 자주 발생하지 않는 컬럼
  - WHERE나 ORDER BY, JOIN 등이 자주 사용되는 컬럼
  - 데이터의 중복도가 낮은 컬럼

- 인덱스를 효율적으로 설정하는 컬럼

  - 한 테이블당 3~5개의 인덱스를 설정하는 것이 적당하다. 후보 컬럼의 특징을 파악하고 4가지 기준을 사용해야 한다.

  1. 카디널리티
     - 전체 행에 대한 특정 컬럼의 중복 수치를 나타내는 지표
       ex) 주민등록번호와 같은 경우는 중복되는 값이 없기 때문에 카디널리티가 높다고 할 수 있다. 즉, 상대적인 개념
       => 카디널리티가 높을수록 인덱스 설정에 좋은 컬럼. = 한 컬럼이 갖고 있는 값의 중복 정도가 낮을 수록 좋다.
  2. 선택도(Selectivity)

     - 데이터에서 특정 값을 얼마나 잘 선택할 수 있는지에 대한 지표
       계산 방법으로는
       = 컬럼의 특정 값의 row 수/ 테이블의 총 row 수 *100
       = 컬럼의 값들의 평균 row 수 / 테이블의 총 row 수 *100
       즉, 선택도는 특정 필드값을 지정했을 때 선택되는 레코드 수를 전체 테이블 전체 레코드 수로 나눈 것.

     => 선택도가 낮을 수록 인덱스 설정에 좋습니다.(5~10%가 적당)

  3. 활용도
     - 해당 컬럼이 실제 작업에서 얼마나 활용되는지에 대한 값
     - 수동 쿼리 조회, 로직과 서비스에서 쿼리를 날릴 때 WHERE 절에 자주 활용되는지를 판단하면 된다.
       => 활용도가 높을 수록 인덱스 설정에 좋은 컬럼
  4. 중복도
     - 중복도가 없을 수록 인덱스 설정에 좋은 컬럼

- 인덱스의 단점?

  - DB 의 10%정도의 공간이 요구되고 , 인덱스를 생성하는 시간이 크게 요구된다. 또한 DB변경 작업이 잦으면 성능이 저하된다.

- 트랜잭션이란?

  - 데이터베이스 작업의 단위로써 하나 이상의 쿼리를 처리할 때 동일한 Connection 객체를 공유하여 에러가 발생한 경우
    모든 과정을 되돌리기 위한 방법

- 트랜잭션 특징(ACID)

  - 원자성(Atomicity): 트랜잭션에 포함된 작업은 전부 수행되거나 전부 수행되지 않아야 한다.
  - 일관성(Consistency): 트랜잭션을 수행하기 전이나 후나 데이터베이스는 항상 일관된 상태를 유지해야 한다.
  - 고립성(Isolation): 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경중인 데이터 값을 훼손하지 않아야한다.
  - 지속성(Durability): 수행을 성공적으로 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야 한다.

- 이상 현상 종류

  - 삭제 이상: 튜플 삭제 시 같이 저장된 다른 정보까지 연쇄적으로 삭제되는 현상
  - 삽입 이상: 튜플 삽입 시 특정 속성에 해당하는 값이 없어 NULL을 입력해야 하는 현상
  - 수정 이상: 튜플 수정 시 중복된 데이터의 일부만 수정되어 일어나는 데이터 불일치 현상

- 정규화란?

  - 하나의 릴레이션에 하나의 의미만 존재하도록 릴레이션을 분해하는 과정이며
  - 데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연성을 위한 방법입니다.
  - 즉, 중복된 데이터를 허용하지 않음으로 무결성을 유지하고, DB의 저장 용량을 줄일 수 있습니다.

  1 정규화 : 테이블의 컬럼이 원자값(하나의 값)을 갖도록 테이블을 분해
  2 정규화 : 1 정규화를 진행한 테이블에 대해 완전 함수 종속을 만족하도록 테이블을 분해
  완전함수 종속이란? : 기본키의 부분집합이 결정자가 되어선 안된다.
  3 정규화 : 이행적 종속을 없애도록 테이블을 분해
  BCNF 정규화: 모든 결정자가 후보키가 되도록 테이블을 분해

- 정규화의 목적

  - 불필요한 데이터를 제거하여 불필요한 중복을 최소화하고
  - 삽입/갱신/삭제 시 발생하는 이상현상을 방지하기 위하여 정규화를 합니다.

- 정규화의 장단점

  - 장점
    1. 데이터베이스 변경 시 이상현상이 발생하는 문제점 해결
    2. 데이터베이스 구조 확장 시 정규화 된 데이터베이스는 그 구조를 변경하지 않아도 되거나 일부만 변경해도 된다.
  - 단점
    1. 릴레이션의 분해로 릴레이션 간의 연산(JOIN 연산) 이 많아진다. 이로 인해 질의에 대한 응답 시간이 느려질 수 있다.

- 역정규화를 하는 이유

  - 정규화를 거쳤을 때 JOIN 연산이 많아져, 성능이 저하될 우려가 있는데
    이 성능 문제가 있는(읽기 작업이 많이 필요한) DB의 전반적인 성능을 향상시키기 위해 합니다.

- 교착 상태

  - 2개 이상의 트랜젝션이 특정 자원(테이블 또는 행)의 잠금(Lock)을 획득한 채 다른 트랜젝션이 소유하고 있는
    잠금을 요구하면 아무리 기다려도 상황이 바뀌지 않는 상태가 되는데 이를 교착상태라고 한다.

- 교착 상태 방지 방법
  1. 트랜잭션을 자주 커밋한다.
  2. 정해진 순서로 테이블에 접근한다
  3. SELECT ~ FOR UPDATE의 사용을 피한다.
