### OOP에 대해서 설명해주세요.
 - 데이터를 객체로 취급하여 프로그램에 반영하고, 순차적으로 프로그램이 동작하는 것과는 다르게 객체의 상호작용을 통해 프로그램이 동작하는 것을 말합니다.
  객체를 연결시켜 프로그래밍하면 상속, 캡슐화, 다형성을 이용해 코드 재사용을 증가시키고, 유지보수를 감소시켜주는 장점이 있습니다.

### 객체지향의 설계원칙에 대해 설명해주세요.
1. SRP - 단일 책임 원칙 : 한 클래스는 하나의 책임만 가져야 한다.
2. OCP - 개방-폐쇄 원칙 : 확장에는 열려있고, 수정에는 닫혀있어야 한다.
3. LSP - 리스코프 치환 원칙 : 상위 타입은 항상 하위 타입으로 대체할 수 있어야 한다.
4. ISP - 인터페이스 분리 원칙 : 인터페이스 내에 메소드는 최소한 일수록 좋다. (하나의 일반적인 인터페이스보다 여러 개의 구체적인 인터페이스가 낫다.) SRP와 같은 문제에 대한 두 가지 다른 해결책이다.
5. DIP - 의존관계 역전 원칙 : 구체적인 클래스보다 상위 클래스, 인터페이스, 추상클래스와 같이 변하지 않을 가능성이 높은 클래스와 관계를 맺어라. DIP 원칙을 따르는 가장 인기 있는 방법은 의존성 주입(DI)이다.

### 다형성에 대해서 설명해보세요
다형성이란, 하나의 메소드나 클래스가 있을 때 이들이 다양한 방법으로 동작하는 것을 의미합니다.

### 자바의 메모리 영역에 대해서 설명해보세요.
- 자바의 메모리 공간은 크게 Method 영역, Stack 영역, Heap 영역으로 구분되고, 데이터 타입에 따라 할당됩니다.
- 메소드(Method) 영역 : 전역변수와 static변수를 저장하며, Method영역은 프로그램의 시작부터 종료까지 메모리에 남아있다.
- 스택(Stack) 영역 : 지역변수와 매개변수 데이터 값이 저장되는 공간이며, 메소드가 호출될 때 메모리에 할당되고 종료되면 메모리가 해제된다. LIFO(Last In First Out) 구조를 갖고 변수에 새로운 데이터가 할당되면 이전 데이터는 지워진다.
- 힙(Heap) 영역 : new 키워드로 생성되는 객체(인스턴스), 배열 등이 Heap 영역에 저장되며, 가비지 컬렉션에 의해 메모리가 관리되어 진다.

### 각 메모리 영역이 할당되는 시점은 언제인가요?
- Method 영역 : JVM이 동작해서 클래스가 로딩될 때 생성
- Stack 영역 : 런타임시 할당
- Heap 영역 : 컴파일 타임 시 할당
※ 컴파일 타임 : 소스코드가 기계어로 변환되어 실행가능한 프로그램이 되는 과정 
※ 런타임 : 컴파일 타임 이후 프로그램이 실행되는 때

### 인터페이스가 무엇인가요? 왜 사용하나요?
인터페이스는 모든 메서드가 추상 메서드로 이루어진 클래스입니다. 특징으로는 따로 abstract를 쓰지 않아도 모두 추상 메서드로 정의가 되구요. 선언한 변수는 자동으로 final static 키워드가 붙습니다.
사용하는 이유는 예를 들면.. 인터페이스는 팀 작업을 할 때 개발코드와 객체가 서로 통신하는 접점 역할을 지원합니다. 개발코드에서는 객체의 내부 구조를 모르더라도 인터페이스의 메서드 명만 알면 다른 팀의 작업을 기다리지 않아도 됩니다. 또한 해당 객체가 수정이 되더라도, 개발 코드 부분은 수정하지 않아도 되는 장점도 있습니다. 이처럼 인터페이스를 통해 팀 단위로 큰 프로젝트를 효율적으로 진행할 수 있습니다.

### 메모리 상수풀 영역에 대해 설명해보세요.
힙 영역에서 생성되고 자바 프로세스 종료까지 계속 유지되는 메모리 영역입니다. 기본적으로 JVM에서 관리하고 있구요. 프로그래머가 작성한 상수에 대해 최우선으로 찾아보고 없으면 상수풀에 추가한 후 그 주소값을 리턴해줍니다. 이로써 메모리 절약 효과를 가져올 수 있습니다.

### 직렬화란 무엇인가요 ?
자바에서 입출력에 사용되는 것은 스트림이라는 데이터 통로를 통해 이동합니다. 하지만 객체는 바이트형이 아니기 때문에 스트림을 통해서 저장하거나 네트워크로 전송하는 것이 불가능합니다. 따라서 객체를 스트림으로 입출력하기 위해서 바이트 배열로 변환하는 것을 직렬화라고 합니다.
반대로 스트림으로 받은 직렬화된 객체를 다시 원래로 돌리는 건 역직렬화라고 말합니다.

### serialVersionUID를 선언해야 하는 이유는 뭔가요?
JVM은 직렬화나 역직렬화를 하는 시점의 클래스에 대해 version 번호를 부여합니다. 그런데 만약 이 시점에서 클래스의 정의가 바뀌게 되면, version 번호도 새롭게 할당해주는데요. 직렬화와 역직렬화의 version 번호가 서로 다르면 안되기 때문에 serialVersionUID를 선언해서 문제를 해결할 수 있습니다.
즉, 클래스 버전이 맞는지 확인하기 위한 용도로 사용된다고 말씀드릴 수 있습니다.

### 리플렉션이란 무엇인가요?
- 리플렉션이란 구체적인 클래스 타입을 알지 못해도 그 클래스의 메소드, 타입, 변수들에 접근할 수 있도록 해주는 자바 API 입니다.

### 리플렉션은 어떤 경우에 사용되는지 설명해주세요.
코드를 작성할 시점에는 어떤 타입의 클래스를 사용할지 모르지만, 런타임 시점에 지금 실행되고 있는 클래스를 가져와서 실행해야 하는 경우 사용됩니다.
프레임워크나 IDE에서 이런 동적인 바인딩을 이용한 기능을 제공합니다. intelliJ의 자동완성 기능, 스프링의 어노테이션이 리플렉션을 이용한 기능이라 할 수 있습니다.

### 클래스 멤버 변수 초기화 순서에 대해 설명해주세요.
static 변수 선언부는 클래스가 로드 될 때 변수가 제일 먼저 초기화 됩니다. 필드 변수 선언부는 객체가 생성될 때 heap 메모리에 올라가고 생성자 block보다 앞서 초기화됩니다. 생성자 block은 객체가 생성 될 때 마찬가지로 heap 메모리에 올라가는데요. 이때 필드 변수가 초기화 될 때까지 JVM에서 내부적으로 로킹해줍니다.

### 제너릭이 무엇인가요?
클래스를 선언할 때 타입을 결정하지 않고 객체 생성 시 유동적으로 재사용하기 위한 것을 말합니다. 제너릭을 활용하면 따로 형변환할 필요가 없고, 타입 에러가 발생하지 않기 때문에 유용하게 사용할 수 있습니다.

### 컬렉션 클래스에서 제너릭을 사용하는 이유를 설명하세요
컬렉션 클래스에서 제너릭을 사용하면, 컴파일러는 특정한 타입만 포함될 수 있도록 컬렉션을 제한합니다. 컬렉션 클래스에 저장되는 인스턴스 타입을 제한하여 런타임에 발생할 수 있는 잠재적인 모든 예외를 컴파일 타임에 잡아낼 수 있도록 도와주기 때문에 사용합니다.

### 박싱과 언박싱에 대해 설명하세요
원시형을 Wrapper Class로 변환하는 것이 박싱이고,
Wrapper Class를 원시형으로 변환하는 것이 언박싱입니다.

### 데드락이 무엇이고, 해결방법에 대해 설명해보세요
데드락이란, 둘 이상의 스레드가 lock을 획득하기 위해 기다리는데, 이 lock을 잡고 있는 스레드도 똑같이 다른 lock을 기다리면서 서로 블락 상태에 놓이는 것을 말합니다. 데드락은 다수의 스레드가 같은 lock을 동시에 다른 명령에 의해 획득하려 할 때 발생할 수 있는데요. 해결방법으로는 우선 순위를 선정해 자원을 선점하도록 하는 것과 공유 불가능한 상호 배제 조건을 제거하는 것이 있습니다.

### 상속과 컴포지션(합성)의 차이에 대해서 설명해보세요
상속은 is a 관계, 컴포지션은 개체들 간의 has a 관계입니다.
상속은 클래스를 확장해 부모 클래스에서 속성 및 동작을 상속하는 기능이구요. 컴포지션은 클래스가 구성원 데이터로 다른 클래스의 객체를 포함할 수 있는 능력입니다.

### JVM이 하는 역할이 무엇인가요?
- JVM은 스택 기반으로 동작하며, Java Byte Code를 OS에 맞게 해석해주는 역할을 하고 가비지 컬렉션을 통해 자동적인 메모리 관리를 해줍니다.

### Java의 특징을 설명해주세요.
- Java는 객체지향 프로그래밍 언어입니다.
- 기본 자료형을 제외한 모든 요소들이 객체로 표현되고, 객체 지향 개념의 특징인 캡슐화, 상속, 다형성이 잘 적용된 언어입니다.
- 장점
  - JVM(자바가상머신) 위에서 동작하기 때문에 운영체제에 독립적이다.
  - 가비지컬렉터를 통한 자동적인 메모리 관리가 가능하다.
- 단점
  - JVM 위에서 동작하기 때문에 실행속도가 상대적으로 느리다.
  - 다중 상속이나 타입에 엄격하며, 제약이 많다.
  
### Java의 컴파일 과정에 대해 설명해주세요.
- 개발자가 .java 파일을 생성한다.
- build를 한다.
- java compoiler의 javac의 명령어를 통해 바이트코드(.class)를 생성한다.
- Class Loader를 통해 JVM 메모리 내로 로드한다.
- 실행엔진을 통해 컴퓨터가 읽을 수 있는 기계어로 해석된다.(각 운영체제에 맞는 기계어)

### Java에서 제공하는 원시 타입들에 무엇이 있고, 각각 몇 바이트를 차지하나요?
- 정수형 byte, short, int, long 실수형 float, double 문자형 char 논리형 boolean이 있고,
- 정수형 1,2,4,8, 실수형 4,8, 문자형 2, 논리형 1 바이트를 차지합니다.

### 오버라이딩과 오버로딩에 대해 설명해주세요.
- 오버라이딩(Overriding)은 상위 클래스에 있는 메소드를 하위 클래스에서 재정의 하는 것을 말하고,
- 오버로딩(Overloading)은 매개변수의 개수나 타입을 다르게 하여 같은 이름의 메소드를 여러 개 정의하는 것을 말합니다.

